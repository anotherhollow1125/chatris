use anyhow::{Context, Result};
use chatris::cli;
use chatris::game::Game;
#[allow(unused)]
use chatris::game::WorldRuleMinoGenerator;
use chatris::next;
use chatris::print_img::{self, ColorMode::*};
use clap::Parser;
use dialoguer::Input;
use rand::{thread_rng, Rng};
use std::fs;
use std::path::Path;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long, default_value = "tetris_imgs")]
    directory: String,
}

fn dump(g: &Game, dir: impl AsRef<Path>, count: &mut usize) -> Result<()> {
    println!("{}", g.field_info());
    let file_name = format!("{}.png", count);
    let path = dir.as_ref().join(file_name);
    print_img::draw_img(g, 120, path, Colorful)
        .with_context(|| format!("@{}:{}", file!(), line!()))?;
    *count += 1;

    Ok(())
}

fn main() -> Result<()> {
    let args = Args::parse();

    let dir_name = args.directory;
    fs::create_dir_all(&dir_name)?;

    let mut rng = thread_rng();
    let rand_gen = Box::new(move || rng.gen::<u32>());
    let minogen = WorldRuleMinoGenerator::new(rand_gen);
    let mut g = Game::new(minogen, "目標: 1ライン消し".to_string());
    let mut count = 0;

    loop {
        dump(&g, &dir_name, &mut count).with_context(|| format!("@{}:{}", file!(), line!()))?;
        let command = Input::<String>::new().with_prompt("\nChatGPT").interact()?;

        match command.as_str() {
            "SETFIELD" | "SF" => {
                let file_path = Input::<String>::new().with_prompt("File Path").interact()?;
                let fileld_str = std::fs::read_to_string(file_path)?;
                cli::set_field(&mut g, &fileld_str);
            }
            "SETNEXT" | "SN" => {
                let loop_generator = next::LoopGenerator::dialog()?;
                g.set_minogen(Box::new(loop_generator));
            }
            input => {
                let res = cli::input_string_command(&mut g, input);

                if !res {
                    dump(&g, &dir_name, &mut count)
                        .with_context(|| format!("@{}:{}", file!(), line!()))?;
                    break;
                }
            }
        }
    }

    Ok(())
}

/*
ChatGPTさんにテトリスをプレイしていただいきたいです。

コマンドを受けるとテトリミノを操作できるテトリスゲームを用意いたしました。やってみましょう。

ゲーム情報は以下のように与えられます。
.....#....
....###...
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
==========
Current: T
Hold: -
Next: S O Z
Status: Dropping

目標: 1ライン消し
Score: 0
Lines: 0
feedback: -
この行より上までがゲーム情報になります。以降英語交じりのこのフォーマットを与えますが、もし説明する際は日本語でお願いいたします。

最初の21行はフィールドです。上からテトリミノが落ちてきます。テトリミノを落とせなくなったらゲームオーバーです。

フィールドの`.`は空白を表します。`#`は現在操作中のテトリミノを表します。アルファベットは固定されたブロックで、元々なんのテトリミノであったかを表します。

Currentは現在操作しているテトリミノの種類を表します。フィールド中では#で表されています。

Holdはホールドしたテトリミノを表します。

Nextは次に出現するテトリミノを表します。左ほど先に来ます。未来を表しており、まだ降ってきてはいないことに注意してください。

Statusはテトリミノの状態を表します。Droppingはテトリミノを下にまだ移動できることを表し、Groundedはテトリミノはこれ以上下がれないことを示します。
StatusがGame Overの時はゲームオーバーで、あなたの負けです。

落下中かは着地中かは後述する;コマンドの挙動に影響します。

目標はChatGPTさんの勝利条件です。勝利していただきたいです。

Scoreはスコアです。Linesは消したライン数です。

feedbackは直前の行動について良かった点・問題点等を記述します。最初や特にない場合は省略されています。

ここからは、ChatGPTさんに答えてもらいたいコマンドに関する説明をします。わかりやすさのためMarkdownのテーブルで与えます。

|コマンド|意味|
|:-------|:---|
|R|右回転|
|L|左回転|
|V|テトリミノが下方向に1下がります。|
|>|テトリミノが右方向に1動きます。|
|<|テトリミノが左方向に1動きます。|
|H|現在のテトリミノをホールド(Hold)します。|
|;|StatusがDroppingの時は、テトリミノを下に移動できるだけ移動します。StatusがGroundedの時はテトリミノを固定し、新しいテトリミノを降らせます。ハードドロップに近い動作です。|

ミノには向きがあります。Rコマンド、すなわち右回転ではNorth -> East -> South -> West -> Northという順で回転します。また、Lコマンドで逆回転します。Oミノに向きはなく回転しません。

ミノは最初Northの状態で降ってきます。以下はミノと向きの関係です。一番左上のマスの座標をテトリミノの座標として扱ってください。

IミノNorth

....
####
....
....

TミノNorth

.#.
###
...

TミノEast

.#.
.##
.#.

TミノSouth

...
###
.#.

TミノWest

.#.
##.
.#.

IミノEast

..#.
..#.
..#.
..#.

IミノSouth

....
....
####
....

IミノWest

.#..
.#..
.#..
.#..

SミノNorth

.##
##.
...

SミノEast

.#.
.##
..#

SミノSouth

...
.##
##.

SミノWest

#..
##.
.#.

ZミノNorth

##.
.##
...

ZミノEast

..#
.##
.#.

ZミノSouth

...
##.
.##

ZミノWest

.#.
##.
#..

JミノNorth

#..
###
...

.##
.#.
.#.

...
###
..#

.#.
.#.
##.

LミノNorth

..#
###
...

LミノEast

.#.
.#.
.##

LミノSouth

...
###
#..

LミノWest

##.
.#.
.#.

;コマンドの扱いには注意してください。テトリミノがまだ下に動ける時は下まで降りる動作のみで、テトリミノがもう下に動けない時にテトリミノが固定されるコマンドです。もし単にハードドロップしたいだけであれば;;のように2つ連続で記述してください。1つ目の;で一番下まで落ち、2つ目の;で固定が行われます。

スーパーローテーションシステムなど、その他ルールの詳細は、ワールドルールに則るものとします。

ChatGPTさんには以下の項目をJSONで返していただきたいです。

- 現在の"状況"の解析
- 目標達成のために取るべき"行動"
- 行動の"理由"
- 以下内容の配列 "command候補"
    - フィールド上でのテトリミノの"目標地点"。フィールドを配列と文字列で表現し、目標地点でテトリミノを固定する場合はテトリミノの文字で、固定しない場合は#で示してください。
    - 目標地点への配置を実現する"command"
    - commandの"実行結果"。ライン消去は行わないでください
    - commandの実行結果が最初に決めた目標地点と一致するかの"判定"。一致する際はtrue, 一致しない際はfalse
    - 判定で一致しなかった場合に何が問題であったかの"考察"。一致した場合は空文字列にしてください。

command候補はそれまでに出力した内容を踏まえて出力してください。

command候補配列は、判定がtrueになるか、要素が10個になるまで出力してください。判定で一致しなかった場合、次に出力するcommandは考察を参考に改善を試みてください。

command候補の最後のcommandを実行した後のフィールド状況を返します。

説明には座標を使用して構いません。プログラミングにおける配列の表現に合わせ0オリジンとし、(x, y)はx列目のy行目を表します。

以下は私とChatGPTさんのやりとりの例です。

私:
.....#....
....###...
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
J.........
JJJ...IIII
==========
Current: T
Hold: -
Next: L O S
Status: Dropping

目標: 1ライン消し
Score: 0
Lines: 0
feedback: -

ChatGPT:
{
    "状況": "Tミノが降り始めており、(0, 4)にあります。Holdはありません。最下段の左から4番目から3つ穴が空いており、そこにTミノを入れればラインが消せそうです。",
    "行動": "Tミノを(18, 3)に移動させ最下段を固定します。",
    "理由": "これで最下段を消すことができるためです。",
    "command候補": [
        {
            "目標地点": [
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "J...T.....",
                "JJJTTTIIII",
            ],
            "command": "<<;;",
            "実行結果": [
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "...T......",
                "J.TTT.....",
                "JJJ...IIII",
            ],
            "判定": false,
            "考察": "左に移動させすぎました。"
        },
{
            "行き先": [
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "J...T.....",
                "JJJTTTIIII",
            ],
            "command": "<;;",
            "実行結果": [
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "..........",
                "J...T.....",
                "JJJTTTIIII",
            ],
            "判定": true,
            "考察": ""
        },
    ]
}

私:
......#...
....###...
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
J...T.....
==========
Current: L
Hold: -
Next: O S Z
Status: Dropping

目標: 1ライン消し
Score: 119
Lines: 1
feedback: -
ここより上の行までがやり取りの例です。

次は特にChatGPTさんに守っていただきたい事項です。

- プレイするのは私ではなくChatGPTさんです。コマンドを返答してください。
    - 「申し訳ありませんがプレイできません」や「最初のコマンドをお知らせください」みたいな返答はダメです。そういう時は`;`を返してください。
- 1ライン以上消せることをChatGPTさんの勝利条件かつ目標とします。
- 勝つまでコマンドを返答し続けてください。

では以下の状態からゲームスタートです。

TODO
- 東西南北で書いてたけど考えてみればこれはテトリミノの向きだったので修正したい..と思ったけどやっぱ回転と衝突するし直す必要ないかも: <>Vでどう？
- 操作の具体例をもっと増やす
- 操作後の盤面を予想させる。(間違っていたら手戻りさせる...?)

- Step By Stepよりも例示の方が効果があった。
- それまでの出力にかなり引っ張られるみたいなので、いきなり答えを求めるのではなくて
- やはり赤子を相手にするように簡単な問題から解かせるべきかもしれない。

- 実行させるのも大変みたい。こっちが作ったルールをまず理解しているかを問うたほうがいいかも。
- 「命令を解釈する」などにアルゴリズムを付けさせる手は有効かも

 */
